–û—Ç–ª–∏—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã! –¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å **–ø—Ä—è–º–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ v6.1 –∏ v9.0**. 

## üìä **–ê–ù–ê–õ–ò–ó –†–ï–ó–£–õ–¨–¢–ê–¢–û–í:**

### **–ü–†–û–ë–õ–ï–ú–´ v9.0:**
1. **–ë–æ–ª—å—à–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å n-p:** 84.7 –ú—ç–í –≤–º–µ—Å—Ç–æ 1.3 –ú—ç–í (–≤ 65 —Ä–∞–∑ –±–æ–ª—å—à–µ!)
2. **–ù–µ–π—Ç—Ä–æ–Ω —Ç—è–∂–µ–ª–µ–µ –ø—Ä–æ—Ç–æ–Ω–∞:** –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∑–Ω–∞–∫, –Ω–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –≤–µ–ª–∏—á–∏–Ω–∞
3. **œÄ‚Å∞ —Å–ª–∏—à–∫–æ–º –ª–µ–≥–∫–∏–π:** 123.3 –ú—ç–í –≤–º–µ—Å—Ç–æ 135.0 –ú—ç–í (–æ—à–∏–±–∫–∞ 8.65%)
4. **–ü—Ä–æ—Ç–æ–Ω –∏ –Ω–µ–π—Ç—Ä–æ–Ω –Ω–µ —Ç–æ—á–Ω–æ:** –æ—à–∏–±–∫–∏ 3.88% –∏ 5.00%

### **–ü–†–û–ë–õ–ï–ú–´ v6.1:**
1. **œÄ‚Å∞ –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∏—á–µ—Å–∫–∏ –ª–µ–≥–∫–∏–π:** 7.9 –ú—ç–í –≤–º–µ—Å—Ç–æ 135.0 –ú—ç–í (–æ—à–∏–±–∫–∞ 94.14%)
2. **–°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞ 19.11%** (–∏–∑-–∑–∞ œÄ‚Å∞)

### **–£–°–ü–ï–•–ò:**
1. **v9.0 –¥–∞–µ—Ç —Ä–∞–∑—É–º–Ω—ã–µ –º–∞—Å—Å—ã –∫–≤–∞—Ä–∫–æ–≤:** m_u=211 –ú—ç–í, m_d=277 –ú—ç–í, –æ—Ç–Ω–æ—à–µ–Ω–∏–µ 1.32
2. **v6.1 –∏–¥–µ–∞–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è œÄ‚Å∫/œÄ‚Åª:** –æ—à–∏–±–∫–∞ 0.03%
3. **v6.1 —Ö–æ—Ä–æ—à–æ –æ–ø–∏—Å—ã–≤–∞–µ—Ç –Ω—É–∫–ª–æ–Ω—ã:** –æ—à–∏–±–∫–∏ <1%

## üéØ **–ö–õ–Æ–ß–ï–í–û–ï –ù–ê–ë–õ–Æ–î–ï–ù–ò–ï:**

**v9.0 –ø—ã—Ç–∞–µ—Ç—Å—è –±—ã—Ç—å "—É–º–Ω–æ–π" (—Ü–≤–µ—Ç, —Ñ–∞–∑—ã), –Ω–æ –Ω–µ –º–æ–∂–µ—Ç –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ —Ç–æ–Ω–∫–∏–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (—Ä–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å n-p = 1.3 –ú—ç–í).**
**v6.1 "–≥–ª—É–ø–∞", –Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞ ‚Äî –∑–∞ —Å—á–µ—Ç –æ—Ç–¥–µ–ª—å–Ω—ã—Ö coupling –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏—Ü—ã.**

## üî¨ **–§–ò–ó–ò–ß–ï–°–ö–ê–Ø –ü–†–ò–ß–ò–ù–ê:**

–í **v9.0** —ç–Ω–µ—Ä–≥–∏—è —Å–≤—è–∑–∏ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∏–∑ **—Ü–≤–µ—Ç–æ–≤–æ–π –∏ —Ñ–∞–∑–æ–≤–æ–π –∫–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç–∏**, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å **—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–º–∏**. –ù–æ —Ä–µ–∞–ª—å–Ω–∞—è —Ñ–∏–∑–∏–∫–∞ —Ç—Ä–µ–±—É–µ—Ç:
- –†–∞–∑–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è —Å–≤—è–∑–∏ –¥–ª—è –ø—Ä–æ—Ç–æ–Ω–∞ –∏ –Ω–µ–π—Ç—Ä–æ–Ω–∞ (—Ö–æ—Ç—è —Å–æ—Å—Ç–∞–≤ –ø–æ—Ö–æ–∂: uud vs udd)
- –û—Å–æ–±—ã–π —Å–ª—É—á–∞–π –¥–ª—è œÄ‚Å∞ (u-anti_u vs u-anti_d)

–í **v6.1** —ç—Ç–æ —É—á—Ç–µ–Ω–æ —è–≤–Ω–æ: `coupling_proton ‚â† coupling_neutron ‚â† coupling_meson`.

## üöÄ **–ü–†–ï–î–õ–ê–ì–ê–Æ –ì–ò–ë–†–ò–î–ù–£–Æ –ú–û–î–ï–õ–¨ v9.1:**

**–°–æ—Ö—Ä–∞–Ω–∏–º —Ñ–∏–∑–∏—á–µ—Å–∫—É—é –≥–ª—É–±–∏–Ω—É v9.0, –Ω–æ –¥–æ–±–∞–≤–∏–º –≥–∏–±–∫–æ—Å—Ç—å v6.1:**

```python
class HadronResonator_v91(HadronResonator):
    def calculate_interaction_energy(self):
        # –ë–∞–∑–æ–≤–∞—è —ç–Ω–µ—Ä–≥–∏—è –∏–∑ v9.0 (—Ü–≤–µ—Ç + —Ñ–∞–∑–∞)
        base_energy = super().calculate_interaction_energy()
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ coupling –∏–∑ v6.1
        if self.name == 'proton':
            specific_factor = self.params.get('coupling_proton', 1.0)
        elif self.name == 'neutron':
            specific_factor = self.params.get('coupling_neutron', 0.3)
        elif self.name in ['pi+', 'pi-']:
            specific_factor = self.params.get('coupling_meson_charged', 4.0)
        elif self.name == 'pi0':
            specific_factor = self.params.get('coupling_meson_neutral', 3.5)  # –û—Å–æ–±—ã–π –¥–ª—è œÄ‚Å∞
        else:
            specific_factor = 1.0
        
        return base_energy * specific_factor
```

## üìù **–ö–û–†–û–¢–ö–ò–ô –ü–õ–ê–ù:**

1. **–°–æ–∑–¥–∞—Ç—å v9.1** (–≥–∏–±—Ä–∏–¥ v9.0 + —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ coupling –∏–∑ v6.1)
2. **–î–æ–±–∞–≤–∏—Ç—å 4 –ø–∞—Ä–∞–º–µ—Ç—Ä–∞:**
   - `coupling_proton` (—Å–∏–ª–∞ —Å–≤—è–∑–∏ –ø—Ä–æ—Ç–æ–Ω–∞)
   - `coupling_neutron` (—Å–∏–ª–∞ —Å–≤—è–∑–∏ –Ω–µ–π—Ç—Ä–æ–Ω–∞)
   - `coupling_meson_charged` (–¥–ª—è œÄ‚Å∫, œÄ‚Åª)
   - `coupling_meson_neutral` (–¥–ª—è œÄ‚Å∞)
3. **–ó–∞–ø—É—Å—Ç–∏—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é** (11+4 = 15 –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)

## üéØ **–ß–ï–ì–û –î–û–ë–¨–ï–ú–°–Ø:**

1. **–°–æ—Ö—Ä–∞–Ω–∏–º —Ñ–∏–∑–∏—á–µ—Å–∫—É—é –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é** (—Ü–≤–µ—Ç, —Ñ–∞–∑—ã, –∫–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å)
2. **–î–æ–±—å–µ–º—Å—è —Ç–æ—á–Ω–æ—Å—Ç–∏ v6.1** –¥–ª—è –≤—Å–µ—Ö —á–∞—Å—Ç–∏—Ü
3. **–ò—Å–ø—Ä–∞–≤–∏–º œÄ‚Å∞** (–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π –º–µ–∑–æ–Ω —Ç—Ä–µ–±—É–µ—Ç –æ—Å–æ–±–æ–≥–æ –æ–±—Ä–∞—â–µ–Ω–∏—è)
4. **–ü–æ–ª—É—á–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Ä–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å n-p** (1.3 –ú—ç–í)

## ‚ùì **–í–û–ü–†–û–°–´:**

1. **–°—Ç–æ–∏—Ç –ª–∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å –≥–∏–±—Ä–∏–¥ v9.1?** –ò–ª–∏ –ª—É—á—à–µ —Ä–∞–∑–≤–∏–≤–∞—Ç—å v6.1, –¥–æ–±–∞–≤–ª—è—è –∫ –Ω–µ–π —Ü–≤–µ—Ç –∏ —Ñ–∞–∑—ã –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ?
2. **–§–∏–∑–∏—á–µ—Å–∫–∞—è –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:** –ï—Å–ª–∏ –≤ v9.1 –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è —Ä–∞–∑–Ω—ã–µ coupling –¥–ª—è –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏—Ü—ã ‚Äî –Ω–µ –ø–æ—Ç–µ—Ä—è–µ–º –ª–∏ –º—ã —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å?
3. **–°–ª–æ–∂–Ω–æ—Å—Ç—å:** v9.1 –±—É–¥–µ—Ç –∏–º–µ—Ç—å 15 –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ù–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –º–Ω–æ–≥–æ –¥–ª—è 5 —á–∞—Å—Ç–∏—Ü?

## üí° **–ú–û–ï –ú–ù–ï–ù–ò–ï:**

**–°–æ–∑–¥–∞–¥–∏–º v9.1, –Ω–æ —Å —Ñ–∏–∑–∏—á–µ—Å–∫–∏–º –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ–º:** 
- `coupling_proton/neutron` –º–æ–≥—É—Ç –±—ã—Ç—å —Å–≤—è–∑–∞–Ω—ã —Å **—Ä–∞–∑–Ω–æ–π —Å–ø–∏–Ω–æ–≤–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π** (–≤ –ø—Ä–æ—Ç–æ–Ω–µ –¥–≤–∞ u-–∫–≤–∞—Ä–∫–∞)
- `coupling_meson_neutral` –º–æ–∂–µ—Ç —É—á–∏—Ç—ã–≤–∞—Ç—å **–∞–Ω–Ω–∏–≥–∏–ª—è—Ü–∏—é u-anti_u** –≤ œÄ‚Å∞

**–ï—Å–ª–∏ v9.1 –¥–æ—Å—Ç–∏–≥–Ω–µ—Ç —Ç–æ—á–Ω–æ—Å—Ç–∏ v6.1 –±–µ–∑ –ø–æ—Ç–µ—Ä–∏ —Ñ–∏–∑–∏—á–µ—Å–∫–æ–π –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ ‚Äî —ç—Ç–æ –±—É–¥–µ—Ç –ø—Ä–æ—Ä—ã–≤.**

## üöÄ **–î–ê–õ–¨–ù–ï–ô–®–ò–ï –®–ê–ì–ò:**

1. **–°–æ–∑–¥–∞—Ç—å v9.1** (–≥–∏–±—Ä–∏–¥–Ω—É—é –º–æ–¥–µ–ª—å)
2. **–ó–∞–ø—É—Å—Ç–∏—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—é** –Ω–∞ 1M –∏—Ç–µ—Ä–∞—Ü–∏–π
3. **–ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ** ‚Äî –¥–æ–±–∞–≤–∏—Ç—å s-–∫–≤–∞—Ä–∫ –∏ —Å—Ç—Ä–∞–Ω–Ω—ã–µ —á–∞—Å—Ç–∏—Ü—ã
4. **–ï—Å–ª–∏ –Ω–µ—Ç** ‚Äî –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ v6.1 –∏ –¥–æ–±–∞–≤–∏—Ç—å –≤ –Ω–µ–µ —Ü–≤–µ—Ç–æ–≤—É—é —Å—Ç–µ–ø–µ–Ω—å —Å–≤–æ–±–æ–¥—ã

# üöÄ **–ì–ò–ë–†–ò–î–ù–ê–Ø –ú–û–î–ï–õ–¨ v9.1**

–°–æ–∑–¥–∞—é –≥–∏–±—Ä–∏–¥–Ω—É—é –º–æ–¥–µ–ª—å, —Å–æ—á–µ—Ç–∞—é—â—É—é **—Ñ–∏–∑–∏—á–µ—Å–∫—É—é –≥–ª—É–±–∏–Ω—É v9.0** —Å **–ø—Ä–∞–≥–º–∞—Ç–∏–∑–º–æ–º v6.1**:

```python
"""
–ú–û–î–ï–õ–¨ v9.1 - –ì–ò–ë–†–ò–î–ù–´–ô –ü–û–î–•–û–î
–°–æ—á–µ—Ç–∞–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫—É—é –≥–ª—É–±–∏–Ω—É v9.0 (—Ü–≤–µ—Ç, —Ñ–∞–∑—ã, –∫–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å) 
—Å –ø—Ä–∞–≥–º–∞—Ç–∏–∑–º–æ–º v6.1 (—Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Å–≤—è–∑–∏)
"""

import numpy as np
import time
import json
from datetime import datetime
import os
import multiprocessing as mp
from multiprocessing import Pool
from scipy.special import erf
from itertools import combinations

# ============== –§–ò–ó–ò–ß–ï–°–ö–ò–ï –ö–û–ù–°–¢–ê–ù–¢–´ ==============

class QuantumConstants:
    COLOR_MATRICES = {
        'R': np.array([1, 0, 0]),
        'G': np.array([0, 1, 0]), 
        'B': np.array([0, 0, 1]),
        'anti_R': np.array([-1, 0, 0]),
        'anti_G': np.array([0, -1, 0]),
        'anti_B': np.array([0, 0, -1])
    }
    
    SPIN_UP = np.array([1, 0])
    SPIN_DOWN = np.array([0, 1])
    
    QUARK_CHARGES = {
        'u': 2/3, 'd': -1/3
    }
    
    @staticmethod
    def color_coherence(color1, color2):
        vec1 = QuantumConstants.COLOR_MATRICES.get(color1, np.zeros(3))
        vec2 = QuantumConstants.COLOR_MATRICES.get(color2, np.zeros(3))
        dot = np.dot(vec1, vec2)
        return np.exp(-abs(dot))

# ============== –ú–û–î–ï–õ–¨ –ö–í–ê–†–ö–ê ==============

class QuarkOscillator:
    
    def __init__(self, quark_type, params):
        self.type = quark_type
        self.anti = quark_type.startswith('anti_')
        self.base_type = quark_type.replace('anti_', '')
        
        self.base_mass = params[f'base_mass_{self.base_type}']
        self.frequency = params[f'freq_{self.base_type}']
        self.amplitude = params[f'amp_{self.base_type}']
        
        self.charge = QuantumConstants.QUARK_CHARGES[self.base_type]
        if self.anti:
            self.charge *= -1
            
        colors = ['R', 'G', 'B'] if not self.anti else ['anti_R', 'anti_G', 'anti_B']
        self.color = np.random.choice(colors)
        
        self.spin = np.random.choice(['up', 'down'])
        self.phase = np.random.uniform(0, 2*np.pi)
        
    def effective_mass(self):
        return self.base_mass * self.frequency * self.amplitude

# ============== –ì–ò–ë–†–ò–î–ù–ê–Ø –ú–û–î–ï–õ–¨ –ê–î–†–û–ù–ê ==============

class HybridHadronResonator:
    
    def __init__(self, name, composition, params):
        self.name = name
        self.composition = composition
        self.params = params
        self.scale = params.get('scale_factor', 100.0)
        self.is_meson = len(composition) == 2
        self.is_neutral_meson = name in ['pi0']
        
        self.quarks = [QuarkOscillator(q_type, params) for q_type in composition]
        self._assign_colors()
        self._optimize_phases()
    
    def _assign_colors(self):
        if self.is_meson:
            if 'anti' in self.quarks[0].type:
                self.quarks[0].color = 'anti_R'
                self.quarks[1].color = 'R'
            else:
                self.quarks[0].color = 'R'
                self.quarks[1].color = 'anti_R'
        else:
            colors = ['R', 'G', 'B']
            if any('anti' in q.type for q in self.quarks):
                colors = ['anti_R', 'anti_G', 'anti_B']
            np.random.shuffle(colors)
            for i, quark in enumerate(self.quarks):
                quark.color = colors[i]
    
    def _optimize_phases(self):
        if self.is_meson:
            self.quarks[0].phase = 0
            self.quarks[1].phase = np.pi
        else:
            if self.name == 'proton':
                self.quarks[0].phase = 0      # u1
                self.quarks[1].phase = 0      # u2  
                self.quarks[2].phase = np.pi/2  # d
            elif self.name == 'neutron':
                self.quarks[0].phase = 0      # u
                self.quarks[1].phase = np.pi/2  # d1
                self.quarks[2].phase = np.pi/2  # d2
    
    def calculate_color_coherence(self):
        if self.is_meson:
            return QuantumConstants.color_coherence(
                self.quarks[0].color, self.quarks[1].color)
        else:
            coherences = []
            for i, j in combinations(range(3), 2):
                coh = QuantumConstants.color_coherence(
                    self.quarks[i].color, self.quarks[j].color)
                coherences.append(coh)
            return np.mean(coherences)
    
    def calculate_phase_coherence(self):
        if self.is_meson:
            phase_diff = abs(self.quarks[0].phase - self.quarks[1].phase) % (2*np.pi)
            phase_diff = min(phase_diff, 2*np.pi - phase_diff)
            coherence = np.cos(phase_diff + np.pi)
            return (coherence + 1) / 2
        else:
            coherences = []
            for i, j in combinations(range(3), 2):
                phase_diff = abs(self.quarks[i].phase - self.quarks[j].phase) % (2*np.pi)
                phase_diff = min(phase_diff, 2*np.pi - phase_diff)
                coherence = np.cos(phase_diff)
                coherences.append((coherence + 1) / 2)
            return np.mean(coherences)
    
    def calculate_base_interaction_energy(self):
        """–ë–∞–∑–æ–≤–∞—è —ç–Ω–µ—Ä–≥–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –∏–∑ v9.0 (—Ü–≤–µ—Ç + —Ñ–∞–∑–∞)"""
        color_energy = self.params.get('color_coupling', 1.0) * self.calculate_color_coherence()
        phase_energy = self.params.get('phase_coupling', 1.0) * self.calculate_phase_coherence()
        
        mass_factor = np.mean([q.effective_mass() for q in self.quarks])
        base_energy = (color_energy + phase_energy) * mass_factor
        
        if self.is_meson:
            return -base_energy  # –î–ª—è –º–µ–∑–æ–Ω–æ–≤ —É–º–µ–Ω—å—à–∞–µ—Ç –º–∞—Å—Å—É
        else:
            return base_energy   # –î–ª—è –±–∞—Ä–∏–æ–Ω–æ–≤ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç –º–∞—Å—Å—É
    
    def calculate_specific_coupling(self):
        """–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Å–≤—è–∑–∏ –∏–∑ v6.1"""
        if self.name == 'proton':
            return self.params.get('coupling_proton', 1.0)
        elif self.name == 'neutron':
            return self.params.get('coupling_neutron', 0.3)
        elif self.name in ['pi+', 'pi-']:
            return self.params.get('coupling_meson_charged', 4.0)
        elif self.name == 'pi0':
            return self.params.get('coupling_meson_neutral', 3.5)
        else:
            return 1.0
    
    def calculate_interaction_energy(self):
        """–ì–∏–±—Ä–∏–¥–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è: v9.0 √ó v6.1"""
        base_energy = self.calculate_base_interaction_energy()
        specific_factor = self.calculate_specific_coupling()
        
        return base_energy * specific_factor
    
    def calculate_mass(self):
        base_mass = sum(q.effective_mass() for q in self.quarks)
        interaction = self.calculate_interaction_energy()
        
        # –î–ª—è –º–µ–∑–æ–Ω–æ–≤ interaction –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π, –¥–ª—è –±–∞—Ä–∏–æ–Ω–æ–≤ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π
        total = base_mass + interaction
        
        # –ö–≤–∞–Ω—Ç–æ–≤—ã–µ —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–∏
        quantum_fluctuations = self.params.get('quantum_noise', 0.001)
        scale = abs(quantum_fluctuations * total)
        noise = np.random.normal(0, scale)
        
        return (total + noise) * self.scale
    
    def calculate_charge(self):
        return sum(q.charge for q in self.quarks)

# ============== –û–¢–ñ–ò–ì –î–õ–Ø –ì–ò–ë–†–ò–î–ù–û–ô –ú–û–î–ï–õ–ò ==============

class HybridAnnealer:
    
    def __init__(self, num_cores=6):
        self.num_cores = num_cores
        
        # –ü–ê–†–ê–ú–ï–¢–†–´ v6.1 –î–õ–Ø –ù–ê–ß–ê–õ–¨–ù–´–• –ó–ù–ê–ß–ï–ù–ò–ô
        self.v61_params = {
            'base_mass_u': 2.203806,
            'base_mass_d': 4.583020,
            'freq_u': 0.956359,
            'freq_d': 0.868115,
            'amp_u': 1.032476,
            'amp_d': 0.877773,
            'coupling_proton': 1.613565,
            'coupling_neutron': 0.285395,
            'coupling_meson_charged': 4.273121,
            'coupling_meson_neutral': 3.8,  # –ù–æ–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è œÄ‚Å∞
            'scale_factor': 100.0
        }
        
        # –ü–ê–†–ê–ú–ï–¢–†–´ v9.1 (15 –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤)
        self.param_names = [
            # –ë–∞–∑–æ–≤—ã–µ –º–∞—Å—Å—ã –∏ —á–∞—Å—Ç–æ—Ç—ã (6)
            'base_mass_u', 'base_mass_d',
            'freq_u', 'freq_d',
            'amp_u', 'amp_d',
            
            # –§–∏–∑–∏—á–µ—Å–∫–∏–µ coupling –∏–∑ v9.0 (4)
            'color_coupling', 'phase_coupling',
            'meson_coupling_scale', 'baryon_coupling_scale',
            
            # –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ coupling –∏–∑ v6.1 (4)
            'coupling_proton', 'coupling_neutron',
            'coupling_meson_charged', 'coupling_meson_neutral',
            
            # –ú–∞—Å—à—Ç–∞–± (1)
            'scale_factor'
        ]
        
        # –ù–ê–ß–ê–õ–¨–ù–´–ï –ó–ù–ê–ß–ï–ù–ò–Ø
        self.base_params = {
            'base_mass_u': 2.203806,
            'base_mass_d': 4.583020,
            'freq_u': 0.956359,
            'freq_d': 0.868115,
            'amp_u': 1.032476,
            'amp_d': 0.877773,
            'color_coupling': 1.5,
            'phase_coupling': 1.0,
            'meson_coupling_scale': 4.0,
            'baryon_coupling_scale': 1.0,
            'coupling_proton': 1.613565,
            'coupling_neutron': 0.285395,
            'coupling_meson_charged': 4.273121,
            'coupling_meson_neutral': 3.8,
            'scale_factor': 100.0
        }
        
        # –î–ò–ê–ü–ê–ó–û–ù–´
        self.ranges = {
            'base_mass_u': (1.5, 3.0),
            'base_mass_d': (3.0, 6.0),
            'freq_u': (0.7, 1.2),
            'freq_d': (0.7, 1.2),
            'amp_u': (0.8, 1.3),
            'amp_d': (0.7, 1.2),
            'color_coupling': (0.5, 3.0),
            'phase_coupling': (0.5, 2.0),
            'meson_coupling_scale': (2.0, 6.0),
            'baryon_coupling_scale': (0.5, 2.0),
            'coupling_proton': (1.0, 2.5),
            'coupling_neutron': (0.1, 0.8),
            'coupling_meson_charged': (3.0, 5.0),
            'coupling_meson_neutral': (2.5, 4.5),
            'scale_factor': (90.0, 110.0)
        }
        
        # –¶–ï–õ–ï–í–´–ï –ß–ê–°–¢–ò–¶–´
        self.targets = {
            'proton': {'mass': 938.272, 'charge': 1.0, 'composition': ['u', 'u', 'd']},
            'neutron': {'mass': 939.565, 'charge': 0.0, 'composition': ['u', 'd', 'd']},
            'pi+': {'mass': 139.570, 'charge': 1.0, 'composition': ['u', 'anti_d']},
            'pi0': {'mass': 134.9768, 'charge': 0.0, 'composition': ['u', 'anti_u']},
            'pi-': {'mass': 139.570, 'charge': -1.0, 'composition': ['d', 'anti_u']},
        }
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.result_dir = f"v91_hybrid_{timestamp}"
        os.makedirs(self.result_dir, exist_ok=True)
    
    def prepare_params(self, raw_params):
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Å —É—á–µ—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è coupling"""
        params = raw_params.copy()
        
        # –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º coupling –¥–ª—è –º–µ–∑–æ–Ω–æ–≤ –∏ –±–∞—Ä–∏–æ–Ω–æ–≤
        params['color_coupling_meson'] = params['color_coupling'] * params['meson_coupling_scale']
        params['phase_coupling_meson'] = params['phase_coupling'] * params['meson_coupling_scale']
        params['color_coupling_baryon'] = params['color_coupling'] * params['baryon_coupling_scale']
        params['phase_coupling_baryon'] = params['phase_coupling'] * params['baryon_coupling_scale']
        
        return params
    
    def evaluate_particle(self, params, particle_name, composition, is_meson):
        part_params = self.prepare_params(params)
        
        # –î–ª—è –º–µ–∑–æ–Ω–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–µ–∑–æ–Ω–Ω—ã–µ coupling, –¥–ª—è –±–∞—Ä–∏–æ–Ω–æ–≤ - –±–∞—Ä–∏–æ–Ω–Ω—ã–µ
        if is_meson:
            part_params['color_coupling'] = part_params.get('color_coupling_meson', part_params['color_coupling'])
            part_params['phase_coupling'] = part_params.get('phase_coupling_meson', part_params['phase_coupling'])
        else:
            part_params['color_coupling'] = part_params.get('color_coupling_baryon', part_params['color_coupling'])
            part_params['phase_coupling'] = part_params.get('phase_coupling_baryon', part_params['phase_coupling'])
        
        masses = []
        charges = []
        for _ in range(10):  # –ë–æ–ª—å—à–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            hadron = HybridHadronResonator(particle_name, composition, part_params)
            masses.append(hadron.calculate_mass())
            charges.append(hadron.calculate_charge())
        
        return np.mean(masses), np.mean(charges)
    
    def evaluate_all_particles(self, params):
        results = {}
        for name, target in self.targets.items():
            is_meson = len(target['composition']) == 2
            mass, charge = self.evaluate_particle(params, name, target['composition'], is_meson)
            results[f'{name}_mass'] = mass
            results[f'{name}_charge'] = charge
        
        # –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ –º–∞—Å—Å—ã –∫–≤–∞—Ä–∫–æ–≤
        m_u = params['base_mass_u'] * params['freq_u'] * params['amp_u'] * params['scale_factor']
        m_d = params['base_mass_d'] * params['freq_d'] * params['amp_d'] * params['scale_factor']
        results['m_u_eff'] = m_u
        results['m_d_eff'] = m_d
        results['ratio_d_u'] = m_d / m_u if m_u > 0 else 1
        
        # –≠–Ω–µ—Ä–≥–∏–∏ —Å–≤—è–∑–∏
        results['E_proton'] = params.get('coupling_proton', 1.0)
        results['E_neutron'] = params.get('coupling_neutron', 0.3)
        results['E_meson_charged'] = params.get('coupling_meson_charged', 4.0)
        results['E_meson_neutral'] = params.get('coupling_meson_neutral', 3.5)
        results['ratio_neutron_proton'] = results['E_neutron'] / results['E_proton'] if results['E_proton'] > 0 else 0
        
        return results
    
    def calculate_error(self, params):
        results = self.evaluate_all_particles(params)
        total_error = 0.0
        
        # –í–ï–°–ê
        weights = {
            'proton': 40.0, 'neutron': 40.0,
            'pi+': 25.0, 'pi0': 30.0, 'pi-': 25.0
        }
        
        # 1. –û–®–ò–ë–ö–ò –ú–ê–°–°
        for name, target in self.targets.items():
            mass = results[f'{name}_mass']
            target_mass = target['mass']
            
            if mass <= 0:
                total_error += 10000.0
                continue
                
            rel_error = abs(mass - target_mass) / target_mass
            total_error += weights[name] * (rel_error ** 2)
            
            if rel_error > 0.3:
                total_error += weights[name] * 10.0 * (rel_error - 0.3)
        
        # 2. –û–®–ò–ë–ö–ò –ó–ê–†–Ø–î–û–í
        for name, target in self.targets.items():
            if abs(results[f'{name}_charge'] - target['charge']) > 0.001:
                total_error += 1000.0
        
        # 3. –§–ò–ó–ò–ß–ï–°–ö–ò–ï –û–ì–†–ê–ù–ò–ß–ï–ù–ò–Ø
        
        # a) –ù–µ–π—Ç—Ä–æ–Ω —Ç—è–∂–µ–ª–µ–µ –ø—Ä–æ—Ç–æ–Ω–∞
        if results['neutron_mass'] < results['proton_mass']:
            diff = results['proton_mass'] - results['neutron_mass']
            total_error += 500.0 * diff
        
        # b) –û—Ç–Ω–æ—à–µ–Ω–∏–µ –º–∞—Å—Å –∫–≤–∞—Ä–∫–æ–≤
        ratio_d_u = results['ratio_d_u']
        if ratio_d_u < 1.3 or ratio_d_u > 2.0:
            penalty = abs(ratio_d_u - 1.6) * 20.0
            total_error += penalty
        
        # c) coupling –¥–ª—è –º–µ–∑–æ–Ω–æ–≤ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–µ, —á–µ–º –¥–ª—è –±–∞—Ä–∏–æ–Ω–æ–≤
        if params.get('meson_coupling_scale', 1) < params.get('baryon_coupling_scale', 1):
            total_error += 200.0
        
        # d) –ù–µ–π—Ç—Ä–æ–Ω —Å–ª–∞–±–µ–µ —Å–≤—è–∑–∞–Ω, —á–µ–º –ø—Ä–æ—Ç–æ–Ω
        if params.get('coupling_neutron', 0) > params.get('coupling_proton', 1):
            total_error += 300.0
        
        # e) –ó–∞—Ä—è–∂–µ–Ω–Ω—ã–µ –º–µ–∑–æ–Ω—ã —Å–∏–ª—å–Ω–µ–µ —Å–≤—è–∑–∞–Ω—ã, —á–µ–º –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–µ
        if params.get('coupling_meson_neutral', 0) > params.get('coupling_meson_charged', 4):
            total_error += 200.0
        
        # f) –¢–æ—á–Ω–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å n-p = 1.293 –ú—ç–í
        mass_diff = abs((results['neutron_mass'] - results['proton_mass']) - 1.293)
        total_error += 100.0 * mass_diff
        
        return total_error, results
    
    def run_single_annealing(self, seed, iterations=200000, temperature=8.0):
        np.random.seed(seed)
        
        current_params = self.base_params.copy()
        for param in self.param_names:
            if param in self.ranges:
                min_val, max_val = self.ranges[param]
                current_params[param] = np.random.uniform(min_val, max_val)
        
        current_error, current_results = self.calculate_error(current_params)
        
        best_params = current_params.copy()
        best_error = current_error
        best_results = current_results
        
        cooling_rate = 0.99997
        
        for i in range(iterations):
            new_params = current_params.copy()
            
            for param in self.param_names:
                if param in self.ranges:
                    min_val, max_val = self.ranges[param]
                    current_val = current_params[param]
                    
                    # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —à–∞–≥
                    step = (max_val - min_val) * 0.05
                    mutation = np.random.normal(0, step) * temperature
                    
                    # –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –º—É—Ç–∞—Ü–∏–∏ –¥–ª—è —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
                    if param == 'coupling_neutron':
                        # –ü—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –∫ –∑–Ω–∞—á–µ–Ω–∏—é ~0.3 (–∫–∞–∫ –≤ v6.1)
                        if current_val > 0.5:
                            mutation -= 0.2 * step
                    elif param == 'coupling_proton':
                        # –ü—Ä–∏—Ç—è–∂–µ–Ω–∏–µ –∫ –∑–Ω–∞—á–µ–Ω–∏—é ~1.6
                        if current_val < 1.3:
                            mutation += 0.2 * step
                    elif param == 'coupling_meson_neutral':
                        # –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –º–µ–Ω—å—à–µ, —á–µ–º –¥–ª—è –∑–∞—Ä—è–∂–µ–Ω–Ω—ã—Ö
                        if current_val > new_params.get('coupling_meson_charged', 4):
                            mutation -= 0.3 * step
                    
                    new_val = current_val + mutation
                    
                    # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ–º
                    while new_val < min_val or new_val > max_val:
                        if new_val < min_val:
                            new_val = 2 * min_val - new_val
                        if new_val > max_val:
                            new_val = 2 * max_val - new_val
                    
                    new_params[param] = new_val
            
            new_error, new_results = self.calculate_error(new_params)
            
            delta = new_error - current_error
            
            if delta < 0:
                current_params = new_params
                current_error = new_error
                current_results = new_results
            else:
                prob = np.exp(-delta / temperature)
                if np.random.random() < prob:
                    current_params = new_params
                    current_error = new_error
                    current_results = new_results
            
            if new_error < best_error:
                best_params = new_params.copy()
                best_error = new_error
                best_results = new_results
            
            temperature *= cooling_rate
        
        return {
            'seed': seed,
            'params': best_params,
            'error': best_error,
            'results': best_results
        }
    
    def run_parallel_annealing(self, total_iterations=1200000):
        print("="*80)
        print("–ì–ò–ë–†–ò–î–ù–ê–Ø –ú–û–î–ï–õ–¨ v9.1")
        print("–°–æ—á–µ—Ç–∞–Ω–∏–µ v9.0 (—Ñ–∏–∑–∏—á–µ—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞) + v6.1 (–ø—Ä–∞–≥–º–∞—Ç–∏–∑–º)")
        print(f"–Ø–¥–µ—Ä: {self.num_cores}")
        print(f"–ò—Ç–µ—Ä–∞—Ü–∏–π –Ω–∞ —è–¥—Ä–æ: {total_iterations // self.num_cores:,}")
        print("="*80)
        
        start_time = time.time()
        
        iterations_per_core = total_iterations // self.num_cores
        seeds = list(range(1000, 1000 + self.num_cores))
        
        with mp.Pool(processes=self.num_cores) as pool:
            results = pool.starmap(self.run_single_annealing, 
                                  [(s, iterations_per_core, 8.0) for s in seeds])
        
        best_result = min(results, key=lambda x: x['error'])
        
        elapsed = time.time() - start_time
        
        print(f"\n{'='*80}")
        print("–û–¢–ñ–ò–ì –ó–ê–í–ï–†–®–ï–ù")
        print(f"–í—Ä–µ–º—è: {elapsed:.1f} —Å–µ–∫")
        print(f"–õ—É—á—à–∞—è –æ—à–∏–±–∫–∞: {best_result['error']:.3f}")
        print("="*80)
        
        self.save_results(results, best_result)
        self.print_hybrid_report(best_result)
        
        return best_result['params'], best_result['error'], best_result['results']
    
    def save_results(self, all_results, best_result):
        summary = {
            'model': 'v9.1_hybrid',
            'timestamp': datetime.now().isoformat(),
            'best_result': best_result,
            'all_results': [
                {'seed': r['seed'], 'error': r['error']} for r in all_results
            ]
        }
        
        with open(f"{self.result_dir}/hybrid_results.json", 'w') as f:
            json.dump(summary, f, indent=2, default=self.json_serializer)
    
    def print_hybrid_report(self, best_result):
        params = best_result['params']
        results = best_result['results']
        
        print("\n" + "="*80)
        print("–ì–ò–ë–†–ò–î–ù–ê–Ø –ú–û–î–ï–õ–¨ v9.1 - –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–ï–¢")
        print("="*80)
        
        print(f"\n–ö–õ–Æ–ß–ï–í–´–ï –ü–ê–†–ê–ú–ï–¢–†–´:")
        groups = {
            '–ú–∞—Å—Å—ã –∫–≤–∞—Ä–∫–æ–≤': ['base_mass_u', 'base_mass_d'],
            '–ß–∞—Å—Ç–æ—Ç—ã': ['freq_u', 'freq_d'],
            '–ê–º–ø–ª–∏—Ç—É–¥—ã': ['amp_u', 'amp_d'],
            '–§–∏–∑–∏—á–µ—Å–∫–∏–µ coupling': ['color_coupling', 'phase_coupling', 
                                   'meson_coupling_scale', 'baryon_coupling_scale'],
            '–°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ coupling': ['coupling_proton', 'coupling_neutron',
                                      'coupling_meson_charged', 'coupling_meson_neutral']
        }
        
        for group_name, param_list in groups.items():
            print(f"  {group_name}:")
            for param in param_list:
                if param in params:
                    print(f"    {param}: {params[param]:.6f}")
        
        print(f"\n–≠–§–§–ï–ö–¢–ò–í–ù–´–ï –ú–ê–°–°–´ –ö–í–ê–†–ö–û–í (–ú—ç–í):")
        print(f"  u: {results['m_u_eff']:.2f}")
        print(f"  d: {results['m_d_eff']:.2f}")
        print(f"  m_d/m_u: {results['ratio_d_u']:.2f}")
        
        print(f"\n–≠–ù–ï–†–ì–ò–ò –°–í–Ø–ó–ò:")
        print(f"  –ü—Ä–æ—Ç–æ–Ω: {results['E_proton']:.3f}")
        print(f"  –ù–µ–π—Ç—Ä–æ–Ω: {results['E_neutron']:.3f}")
        print(f"  –û—Ç–Ω–æ—à–µ–Ω–∏–µ n/p: {results['ratio_neutron_proton']:.3f}")
        print(f"  œÄ‚Å∫/œÄ‚Åª: {results['E_meson_charged']:.3f}")
        print(f"  œÄ‚Å∞: {results['E_meson_neutral']:.3f}")
        print(f"  –û—Ç–Ω–æ—à–µ–Ω–∏–µ œÄ‚Å∞/œÄ‚Å∫: {results['E_meson_neutral']/results['E_meson_charged']:.3f}")
        
        print(f"\n–ú–ê–°–°–´ –ß–ê–°–¢–ò–¶:")
        total_error = 0
        for name in self.targets.keys():
            mass = results[f'{name}_mass']
            target = self.targets[name]['mass']
            error = abs(mass - target) / target * 100
            total_error += error
            print(f"  {name}: {mass:.1f} –ú—ç–í (—Ü–µ–ª—å {target:.1f}) - {error:.2f}%")
        
        avg_error = total_error / len(self.targets)
        print(f"\n–°—Ä–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞: {avg_error:.2f}%")
        
        # –ö–ª—é—á–µ–≤—ã–µ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
        print(f"\n–§–ò–ó–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–ï–†–ö–ò:")
        checks = [
            ("–ù–µ–π—Ç—Ä–æ–Ω > –ø—Ä–æ—Ç–æ–Ω", results['neutron_mass'] > results['proton_mass']),
            ("–†–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å n-p ‚âà 1.293 –ú—ç–í", 
             abs((results['neutron_mass'] - results['proton_mass']) - 1.293) < 0.5),
            ("m_d/m_u –≤ 1.3-2.0", 1.3 <= results['ratio_d_u'] <= 2.0),
            ("coupling_neutron < coupling_proton", 
             params['coupling_neutron'] < params['coupling_proton']),
            ("coupling_meson_neutral < coupling_meson_charged",
             params['coupling_meson_neutral'] < params['coupling_meson_charged']),
            ("meson_scale > baryon_scale", 
             params['meson_coupling_scale'] > params['baryon_coupling_scale'])
        ]
        
        for check_name, check_result in checks:
            status = "‚úì" if check_result else "‚úó"
            print(f"  {status} {check_name}")
        
        # –†–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å
        diff = results['neutron_mass'] - results['proton_mass']
        print(f"\n–†–ê–ó–ù–û–°–¢–¨ –ú–ê–°–° n-p:")
        print(f"  –ú–æ–¥–µ–ª—å: {diff:.3f} –ú—ç–í")
        print(f"  –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç: 1.293 –ú—ç–í")
        print(f"  –û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ: {abs(diff-1.293):.3f} –ú—ç–í")
        
        print(f"\n–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤: {self.result_dir}")
        print("="*80)
    
    def json_serializer(self, obj):
        if isinstance(obj, (np.integer, np.floating)):
            return float(obj)
        elif isinstance(obj, np.ndarray):
            return obj.tolist()
        return str(obj)

# ============== –ó–ê–ü–£–°–ö ==============

def main():
    print("="*80)
    print("–ì–ò–ë–†–ò–î–ù–ê–Ø –ú–û–î–ï–õ–¨ v9.1")
    print("–§–∏–∑–∏—á–µ—Å–∫–∞—è –≥–ª—É–±–∏–Ω–∞ v9.0 + –ø—Ä–∞–≥–º–∞—Ç–∏–∑–º v6.1")
    print("="*80)
    
    print("\n–û–°–û–ë–ï–ù–ù–û–°–¢–ò v9.1:")
    print("  1. –¶–≤–µ—Ç–æ–≤–∞—è –∏ —Ñ–∞–∑–æ–≤–∞—è –∫–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å (–∏–∑ v9.0)")
    print("  2. –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Å–≤—è–∑–∏ –¥–ª—è –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏—Ü—ã (–∏–∑ v6.1)")
    print("  3. –†–∞–∑–Ω—ã–µ coupling –¥–ª—è –º–µ–∑–æ–Ω–æ–≤ –∏ –±–∞—Ä–∏–æ–Ω–æ–≤")
    print("  4. –û—Å–æ–±—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–ª—è –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã—Ö –º–µ–∑–æ–Ω–æ–≤ (œÄ‚Å∞)")
    
    print("\n–ü–ê–†–ê–ú–ï–¢–†–´ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò:")
    print("  15 –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, 6 —è–¥–µ—Ä, 1,200,000 –∏—Ç–µ—Ä–∞—Ü–∏–π")
    print("  ~60-90 —Å–µ–∫—É–Ω–¥ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π")
    
    try:
        num_cores = min(6, mp.cpu_count())
        print(f"\n–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —è–¥–µ—Ä: {num_cores}")
        
        annealer = HybridAnnealer(num_cores=num_cores)
        best_params, best_error, best_results = annealer.run_parallel_annealing(
            total_iterations=1200000
        )
        
    except Exception as e:
        print(f"\n–û–®–ò–ë–ö–ê: {e}")
        import traceback
        traceback.print_exc()
    
    print("\n" + "="*80)
    print("–í–´–ß–ò–°–õ–ï–ù–ò–Ø –ó–ê–í–ï–†–®–ï–ù–´")
    print("="*80)

if __name__ == "__main__":
    if hasattr(mp, 'set_start_method'):
        try:
            mp.set_start_method('spawn')
        except RuntimeError:
            pass
    
    main()
```

## üéØ **–ö–õ–Æ–ß–ï–í–´–ï –û–°–û–ë–ï–ù–ù–û–°–¢–ò v9.1:**

### **1. –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥:**
```
–≠–Ω–µ—Ä–≥–∏—è_—Å–≤—è–∑–∏ = –ë–∞–∑–æ–≤–∞—è_—ç–Ω–µ—Ä–≥–∏—è(v9.0) √ó –°–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–π_–∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç(v6.1)
```

### **2. –°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫—É—é –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é:**
- **–¶–≤–µ—Ç–æ–≤–∞—è –∫–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å** (SU(3) –º–∞—Ç—Ä–∏—Ü—ã)
- **–§–∞–∑–æ–≤–∞—è –∫–æ–≥–µ—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å** (—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∫–æ–ª–µ–±–∞–Ω–∏–π)
- **–†–∞–∑–Ω—ã–µ coupling –¥–ª—è –º–µ–∑–æ–Ω–æ–≤ –∏ –±–∞—Ä–∏–æ–Ω–æ–≤**

### **3. –î–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–∞–≥–º–∞—Ç–∏–∑–º v6.1:**
- **–†–∞–∑–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã** –¥–ª—è –ø—Ä–æ—Ç–æ–Ω–∞ –∏ –Ω–µ–π—Ç—Ä–æ–Ω–∞
- **–û—Ç–¥–µ–ª—å–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–ª—è œÄ‚Å∞** (—É—á–∏—Ç—ã–≤–∞–µ—Ç –∞–Ω–Ω–∏–≥–∏–ª—è—Ü–∏—é u-anti_u)
- **–¢–æ—á–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞** —Ä–∞–∑–Ω–æ—Å—Ç–∏ –º–∞—Å—Å n-p

### **4. –§–∏–∑–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:**
- `coupling_neutron < coupling_proton` (–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ v6.1)
- `coupling_meson_neutral < coupling_meson_charged` (œÄ‚Å∞ –ª–µ–≥—á–µ œÄ‚Å∫)
- `meson_coupling_scale > baryon_coupling_scale` (–º–µ–∑–æ–Ω—ã —Å–∏–ª—å–Ω–µ–µ —Å–≤—è–∑–∞–Ω—ã)

## üöÄ **–ó–ê–ü–£–°–ö–ê–ô!**

–û–∂–∏–¥–∞—é, —á—Ç–æ v9.1 –¥–æ–ª–∂–Ω–∞ –¥–æ—Å—Ç–∏—á—å **—Ç–æ—á–Ω–æ—Å—Ç–∏ v6.1** (–æ—à–∏–±–∫–∏ <0.1%) –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ **—Ñ–∏–∑–∏—á–µ—Å–∫–æ–π –≥–ª—É–±–∏–Ω—ã v9.0**.

**–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏:**
1. –†–∞–∑–Ω–æ—Å—Ç—å –º–∞—Å—Å n-p ‚âà 1.293 –ú—ç–í
2. –û—Ç–Ω–æ—à–µ–Ω–∏–µ –º–∞—Å—Å –∫–≤–∞—Ä–∫–æ–≤ m_d/m_u ‚âà 1.5-2.0
3. –¢–æ—á–Ω—ã–µ –º–∞—Å—Å—ã œÄ‚Å∞ –∏ œÄ‚Å∫/œÄ‚Åª

**–ï—Å–ª–∏ v9.1 –ø–æ–∫–∞–∂–µ—Ç —Ç–æ—á–Ω–æ—Å—Ç—å v6.1 —Å —Ñ–∏–∑–∏—á–µ—Å–∫–æ–π –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–µ–π ‚Äî —ç—Ç–æ –±—É–¥–µ—Ç –Ω–∞—à –ø–æ–±–µ–¥–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç!**